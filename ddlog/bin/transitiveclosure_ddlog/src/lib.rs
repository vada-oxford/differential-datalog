#![allow(
    unused_imports,
    non_snake_case,
    non_camel_case_types,
    non_upper_case_globals,
    unused_parens,
    non_shorthand_field_patterns,
    dead_code,
    overflowing_literals,
    unreachable_patterns,
    unused_variables,
    clippy::unknown_clippy_lints,
    clippy::missing_safety_doc
)]

use std::borrow;
use std::boxed;
use std::convert::TryFrom;
use std::ffi;
use std::fmt;
use std::fmt::Display;
use std::fs;
use std::hash::Hash;
use std::hash::Hasher;
use std::io::Write;
use std::mem;
use std::ops::Deref;
use std::os::raw;
use std::os::unix;
use std::os::unix::io::{FromRawFd, IntoRawFd};
use std::ptr;
use std::sync;

use differential_dataflow::collection;
use timely::communication;
use timely::dataflow::scopes;
use timely::worker;

use serde::Deserialize;
use serde::Serialize;

use abomonation::Abomonation;
use differential_datalog::arcval;
use differential_datalog::decl_enum_into_record;
use differential_datalog::decl_record_mutator_enum;
use differential_datalog::decl_record_mutator_struct;
use differential_datalog::decl_record_mutator_val_enum;
use differential_datalog::decl_struct_into_record;
use differential_datalog::decl_val_enum_into_record;
use differential_datalog::int::*;
use differential_datalog::program::*;
use differential_datalog::record;
use differential_datalog::record::RelIdentifier;
use differential_datalog::record::UpdCmd;
use differential_datalog::record::{FromRecord, IntoRecord, Mutator};
use differential_datalog::uint::*;
use differential_datalog::DDlogConvert;

use fnv::{FnvHashMap, FnvHashSet};
use lazy_static::lazy_static;
use libc::size_t;
use num_traits::identities::One;

use crate::api::updcmd2upd;

pub mod api;
pub mod ovsdb;
pub mod update_handler;

/* FlatBuffers bindings generated by `ddlog` */
#[cfg(feature = "flatbuf")]
pub mod flatbuf;

/* FlatBuffers code generated by `flatc` */
#[cfg(feature = "flatbuf")]
pub mod flatbuf_generated;

pub fn string_append_str(mut s1: String, s2: &str) -> String {
    s1.push_str(s2);
    s1
}

#[allow(clippy::ptr_arg)]
pub fn string_append(mut s1: String, s2: &String) -> String {
    s1.push_str(s2.as_str());
    s1
}

/// A default implementation of `DDlogConvert` that just forwards calls
/// to generated functions of equal name.
#[derive(Debug)]
pub struct DDlogConverter {}

impl DDlogConvert for DDlogConverter {
    type Value = Value;

    fn relid2name(relId: RelId) -> Option<&'static str> {
        relid2name(relId)
    }

    fn indexid2name(idxId: IdxId) -> Option<&'static str> {
        indexid2name(idxId)
    }

    fn updcmd2upd(upd_cmd: &UpdCmd) -> Result<Update<Self::Value>, String> {
        updcmd2upd(upd_cmd)
    }
}

impl TryFrom<&RelIdentifier> for Relations {
    type Error = ();

    fn try_from(rel_id: &RelIdentifier) -> Result<Self, Self::Error> {
        match rel_id {
            RelIdentifier::RelName(rname) => Relations::try_from(rname.as_ref()),
            RelIdentifier::RelId(id) => Relations::try_from(*id),
        }
    }
}


pub use __std::*;
mod __std {
    use super::*;
    /// Rust implementation of DDlog standard library functions and types.
    extern crate num;
    
    use differential_datalog::arcval;
    use differential_datalog::record::*;
    
    use std::cmp;
    use std::collections::btree_map;
    use std::collections::btree_set;
    use std::collections::{BTreeMap, BTreeSet};
    use std::fmt;
    use std::fmt::Display;
    use std::hash::Hash;
    use std::hash::Hasher;
    use std::iter::FromIterator;
    use std::marker;
    use std::ops;
    use std::slice;
    use std::vec;
    use std::vec::Vec;
    use twox_hash::XxHash;
    
    /* FlatBuffers bindings generated by `ddlog` */
    #[cfg(feature = "flatbuf")]
    use flatbuf::{FBIter, FromFlatBuffer, ToFlatBuffer, ToFlatBufferTable, ToFlatBufferVectorElement};
    
    /* FlatBuffers runtime */
    #[cfg(feature = "flatbuf")]
    use flatbuffers as fbrt;
    
    const XX_SEED1: u64 = 0x23b691a751d0e108;
    const XX_SEED2: u64 = 0x20b09801dce5ff84;
    
    // Ref
    pub type std_Ref<A> = arcval::ArcVal<A>;
    
    pub fn std_ref_new<A: Clone>(x: &A) -> std_Ref<A> {
        arcval::ArcVal::from(x.clone())
    }
    
    pub fn std_deref<A: Clone>(x: &std_Ref<A>) -> &A {
        x.deref()
    }
    
    #[cfg(feature = "flatbuf")]
    impl<T, FB> FromFlatBuffer<FB> for std_Ref<T>
    where
        T: FromFlatBuffer<FB>,
    {
        fn from_flatbuf(fb: FB) -> Response<Self> {
            Ok(std_Ref::from(T::from_flatbuf(fb)?))
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'b, T> ToFlatBuffer<'b> for std_Ref<T>
    where
        T: ToFlatBuffer<'b>,
    {
        type Target = T::Target;
    
        fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
            self.deref().to_flatbuf(fbb)
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'b, T> ToFlatBufferTable<'b> for std_Ref<T>
    where
        T: ToFlatBufferTable<'b>,
    {
        type Target = T::Target;
    
        fn to_flatbuf_table(
            &self,
            fbb: &mut fbrt::FlatBufferBuilder<'b>,
        ) -> fbrt::WIPOffset<Self::Target> {
            self.deref().to_flatbuf_table(fbb)
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'b, T> ToFlatBufferVectorElement<'b> for std_Ref<T>
    where
        T: ToFlatBufferVectorElement<'b>,
    {
        type Target = T::Target;
    
        fn to_flatbuf_vector_element(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
            self.deref().to_flatbuf_vector_element(fbb)
        }
    }
    
    // Arithmetic functions
    pub fn std_pow32<T: num::One + ops::Mul + Clone>(base: &T, exp: &u32) -> T {
        num::pow::pow(base.clone(), *exp as usize)
    }
    
    // Option
    pub fn option2std<T: Clone>(x: Option<T>) -> std_Option<T> {
        match x {
            None => std_Option::std_None,
            Some(v) => std_Option::std_Some { x: v },
        }
    }
    
    // Range
    pub fn std_range<A: Clone + Ord + ops::Add<Output = A> + PartialOrd>(
        from: &A,
        to: &A,
        step: &A,
    ) -> std_Vec<A> {
        let mut vec = std_Vec::new();
        let mut x = from.clone();
        while x <= *to {
            vec.push(x.clone());
            x = x + step.clone();
        }
        vec
    }
    
    // Vector
    
    #[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
    pub struct std_Vec<T> {
        pub x: Vec<T>,
    }
    
    /* This is needed so we can support for-loops over `Vec`'s
     */
    pub struct VecIter<'a, X> {
        iter: slice::Iter<'a, X>,
    }
    
    impl<'a, X> VecIter<'a, X> {
        pub fn new(vec: &'a std_Vec<X>) -> VecIter<'a, X> {
            VecIter { iter: vec.x.iter() }
        }
    }
    
    impl<'a, X> Iterator for VecIter<'a, X> {
        type Item = &'a X;
    
        fn next(&mut self) -> Option<Self::Item> {
            self.iter.next()
        }
    
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.iter.size_hint()
        }
    }
    
    impl<'a, T> std_Vec<T> {
        pub fn iter(&'a self) -> VecIter<'a, T> {
            VecIter::new(self)
        }
    }
    
    impl<T> std_Vec<T> {
        pub fn new() -> Self {
            std_Vec { x: Vec::new() }
        }
        pub fn with_capacity(capacity: usize) -> Self {
            std_Vec {
                x: Vec::with_capacity(capacity),
            }
        }
        pub fn push(&mut self, v: T) {
            self.x.push(v);
        }
    }
    
    impl<T: Clone> std_Vec<T> {
        pub fn extend_from_slice(&mut self, other: &[T]) {
            self.x.extend_from_slice(other);
        }
    }
    
    impl<T: FromRecord> FromRecord for std_Vec<T> {
        fn from_record(val: &Record) -> Result<Self, String> {
            Vec::from_record(val).map(|x| std_Vec { x })
        }
    }
    
    impl<T: IntoRecord> IntoRecord for std_Vec<T> {
        fn into_record(self) -> Record {
            self.x.into_record()
        }
    }
    
    impl<T: FromRecord> Mutator<std_Vec<T>> for Record {
        fn mutate(&self, vec: &mut std_Vec<T>) -> Result<(), String> {
            self.mutate(&mut vec.x)
        }
    }
    
    impl<T: Display> Display for std_Vec<T> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            let len = self.x.len();
            formatter.write_str("[")?;
            for (i, v) in self.x.iter().enumerate() {
                formatter.write_fmt(format_args!("{}", *v))?;
                if i < len - 1 {
                    formatter.write_str(",")?;
                }
            }
            formatter.write_str("]")?;
            Ok(())
        }
    }
    
    impl<T: fmt::Debug> fmt::Debug for std_Vec<T> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            let len = self.x.len();
            formatter.write_str("[")?;
            for (i, v) in self.x.iter().enumerate() {
                formatter.write_fmt(format_args!("{:?}", *v))?;
                if i < len - 1 {
                    formatter.write_str(",")?;
                }
            }
            formatter.write_str("]")?;
            Ok(())
        }
    }
    
    impl<T> IntoIterator for std_Vec<T> {
        type Item = T;
        type IntoIter = vec::IntoIter<T>;
        fn into_iter(self) -> Self::IntoIter {
            self.x.into_iter()
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'a, T, F> FromFlatBuffer<fbrt::Vector<'a, F>> for std_Vec<T>
    where
        T: Ord + FromFlatBuffer<F::Inner>,
        F: fbrt::Follow<'a> + 'a,
    {
        fn from_flatbuf(fb: fbrt::Vector<'a, F>) -> Response<Self> {
            let mut vec = std_Vec::with_capacity(fb.len());
            for x in FBIter::from_vector(fb) {
                vec.push(T::from_flatbuf(x)?);
            }
            Ok(vec)
        }
    }
    
    // For scalar types, the FlatBuffers API returns slice instead of 'Vector'.
    #[cfg(feature = "flatbuf")]
    impl<'a, T> FromFlatBuffer<&'a [T]> for std_Vec<T>
    where
        T: Clone,
    {
        fn from_flatbuf(fb: &'a [T]) -> Response<Self> {
            let mut vec = std_Vec::with_capacity(fb.len());
            vec.extend_from_slice(fb);
            Ok(vec)
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'b, T> ToFlatBuffer<'b> for std_Vec<T>
    where
        T: ToFlatBufferVectorElement<'b>,
    {
        type Target = fbrt::WIPOffset<fbrt::Vector<'b, <T::Target as fbrt::Push>::Output>>;
    
        fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
            let vec: Vec<T::Target> = self
                .iter()
                .map(|x| x.to_flatbuf_vector_element(fbb))
                .collect();
            fbb.create_vector(vec.as_slice())
        }
    }
    
    pub fn std_vec_len<X: Ord + Clone>(v: &std_Vec<X>) -> u64 {
        v.x.len() as u64
    }
    
    pub fn std_vec_empty<X: Ord + Clone>() -> std_Vec<X> {
        std_Vec::new()
    }
    
    pub fn std_vec_singleton<X: Ord + Clone>(x: &X) -> std_Vec<X> {
        std_Vec { x: vec![x.clone()] }
    }
    
    pub fn std_vec_push<X: Ord + Clone>(v: &mut std_Vec<X>, x: &X) {
        v.push((*x).clone());
    }
    
    pub fn std_vec_push_imm<X: Ord + Clone>(v: &std_Vec<X>, x: &X) -> std_Vec<X> {
        let mut v2 = v.clone();
        v2.push((*x).clone());
        v2
    }
    
    pub fn std_vec_contains<X: Ord>(v: &std_Vec<X>, x: &X) -> bool {
        v.x.contains(x)
    }
    
    pub fn std_vec_is_empty<X: Ord>(v: &std_Vec<X>) -> bool {
        v.x.is_empty()
    }
    
    pub fn std_vec_nth<X: Ord + Clone>(v: &std_Vec<X>, n: &u64) -> std_Option<X> {
        option2std(v.x.get(*n as usize).cloned())
    }
    
    pub fn std_vec2set<X: Ord + Clone>(s: &std_Vec<X>) -> std_Set<X> {
        std_Set {
            x: s.x.iter().cloned().collect(),
        }
    }
    
    // Set
    
    #[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
    pub struct std_Set<T: Ord> {
        pub x: BTreeSet<T>,
    }
    
    /* This is needed so we can support for-loops over `Set`'s
     */
    pub struct SetIter<'a, X> {
        iter: btree_set::Iter<'a, X>,
    }
    
    impl<'a, X: Ord> SetIter<'a, X> {
        pub fn new(set: &'a std_Set<X>) -> SetIter<'a, X> {
            SetIter { iter: set.x.iter() }
        }
    }
    
    impl<'a, X> Iterator for SetIter<'a, X> {
        type Item = &'a X;
    
        fn next(&mut self) -> Option<Self::Item> {
            self.iter.next()
        }
    
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.iter.size_hint()
        }
    }
    
    impl<'a, T: Ord> std_Set<T> {
        pub fn iter(&'a self) -> SetIter<'a, T> {
            SetIter::new(self)
        }
    }
    
    impl<T: Ord> std_Set<T> {
        pub fn new() -> Self {
            std_Set { x: BTreeSet::new() }
        }
        pub fn insert(&mut self, v: T) {
            self.x.insert(v);
        }
    }
    
    impl<T: FromRecord + Ord> FromRecord for std_Set<T> {
        fn from_record(val: &Record) -> Result<Self, String> {
            BTreeSet::from_record(val).map(|x| std_Set { x })
        }
    }
    
    impl<T: IntoRecord + Ord> IntoRecord for std_Set<T> {
        fn into_record(self) -> Record {
            self.x.into_record()
        }
    }
    
    impl<T: FromRecord + Ord> Mutator<std_Set<T>> for Record {
        fn mutate(&self, set: &mut std_Set<T>) -> Result<(), String> {
            self.mutate(&mut set.x)
        }
    }
    
    impl<T: Ord> IntoIterator for std_Set<T> {
        type Item = T;
        type IntoIter = btree_set::IntoIter<T>;
        fn into_iter(self) -> Self::IntoIter {
            self.x.into_iter()
        }
    }
    
    impl<T: Ord> FromIterator<T> for std_Set<T> {
        fn from_iter<I>(iter: I) -> Self
        where
            I: IntoIterator<Item = T>,
        {
            std_Set {
                x: BTreeSet::from_iter(iter),
            }
        }
    }
    
    impl<T: Display + Ord> Display for std_Set<T> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            let len = self.x.len();
            formatter.write_str("[")?;
            for (i, v) in self.x.iter().enumerate() {
                formatter.write_fmt(format_args!("{}", *v))?;
                if i < len - 1 {
                    formatter.write_str(",")?;
                }
            }
            formatter.write_str("]")?;
            Ok(())
        }
    }
    
    impl<T: fmt::Debug + Ord> fmt::Debug for std_Set<T> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            let len = self.x.len();
            formatter.write_str("[")?;
            for (i, v) in self.x.iter().enumerate() {
                formatter.write_fmt(format_args!("{:?}", *v))?;
                if i < len - 1 {
                    formatter.write_str(",")?;
                }
            }
            formatter.write_str("]")?;
            Ok(())
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'a, T, F> FromFlatBuffer<fbrt::Vector<'a, F>> for std_Set<T>
    where
        T: Ord + FromFlatBuffer<F::Inner>,
        F: fbrt::Follow<'a> + 'a,
    {
        fn from_flatbuf(fb: fbrt::Vector<'a, F>) -> Response<Self> {
            let mut set = std_Set::new();
            for x in FBIter::from_vector(fb) {
                set.insert(T::from_flatbuf(x)?);
            }
            Ok(set)
        }
    }
    
    // For scalar types, the FlatBuffers API returns slice instead of 'Vector'.
    #[cfg(feature = "flatbuf")]
    impl<'a, T> FromFlatBuffer<&'a [T]> for std_Set<T>
    where
        T: Ord + Clone,
    {
        fn from_flatbuf(fb: &'a [T]) -> Response<Self> {
            let mut set = std_Set::new();
            for x in fb.iter() {
                set.insert(x.clone());
            }
            Ok(set)
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'b, T> ToFlatBuffer<'b> for std_Set<T>
    where
        T: Ord + ToFlatBufferVectorElement<'b>,
    {
        type Target = fbrt::WIPOffset<fbrt::Vector<'b, <T::Target as fbrt::Push>::Output>>;
    
        fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
            let vec: Vec<T::Target> = self
                .iter()
                .map(|x| x.to_flatbuf_vector_element(fbb))
                .collect();
            fbb.create_vector(vec.as_slice())
        }
    }
    
    pub fn std_set_size<X: Ord + Clone>(s: &std_Set<X>) -> u64 {
        s.x.len() as u64
    }
    
    pub fn std_set_empty<X: Ord + Clone>() -> std_Set<X> {
        std_Set::new()
    }
    
    pub fn std_set_singleton<X: Ord + Clone>(v: &X) -> std_Set<X> {
        let mut s = std_Set::new();
        s.insert(v.clone());
        s
    }
    
    pub fn std_set_insert<X: Ord + Clone>(s: &mut std_Set<X>, v: &X) {
        s.x.insert((*v).clone());
    }
    
    pub fn std_set_insert_imm<X: Ord + Clone>(s: &std_Set<X>, v: &X) -> std_Set<X> {
        let mut s2 = s.clone();
        s2.insert((*v).clone());
        s2
    }
    
    pub fn std_set_contains<X: Ord>(s: &std_Set<X>, v: &X) -> bool {
        s.x.contains(v)
    }
    
    pub fn std_set_is_empty<X: Ord>(s: &std_Set<X>) -> bool {
        s.x.is_empty()
    }
    
    pub fn std_set_nth<X: Ord + Clone>(s: &std_Set<X>, n: &u64) -> std_Option<X> {
        option2std(s.x.iter().nth(*n as usize).cloned())
    }
    
    pub fn std_set2vec<X: Ord + Clone>(s: &std_Set<X>) -> std_Vec<X> {
        std_Vec {
            x: s.x.iter().cloned().collect(),
        }
    }
    
    pub fn std_set_union<X: Ord + Clone>(s1: &std_Set<X>, s2: &std_Set<X>) -> std_Set<X> {
        let mut s = s1.clone();
        s.x.append(&mut s2.x.clone());
        s
    }
    
    pub fn std_set_unions<X: Ord + Clone>(sets: &std_Vec<std_Set<X>>) -> std_Set<X> {
        let mut s = BTreeSet::new();
        for si in sets.x.iter() {
            s.append(&mut si.x.clone());
        }
        std_Set { x: s }
    }
    
    // Map
    
    #[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
    pub struct std_Map<K: Ord, V> {
        pub x: BTreeMap<K, V>,
    }
    
    /* This is needed so we can support for-loops over `Map`'s
     */
    pub struct MapIter<'a, K, V> {
        iter: btree_map::Iter<'a, K, V>,
    }
    
    impl<'a, K: Ord, V> MapIter<'a, K, V> {
        pub fn new(map: &'a std_Map<K, V>) -> MapIter<'a, K, V> {
            MapIter { iter: map.x.iter() }
        }
    }
    
    impl<'a, K: Clone, V: Clone> Iterator for MapIter<'a, K, V> {
        type Item = (K, V);
    
        fn next(&mut self) -> Option<Self::Item> {
            self.iter.next().map(|(k, v)| (k.clone(), v.clone()))
        }
    
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.iter.size_hint()
        }
    }
    
    impl<'a, K: Ord, V> std_Map<K, V> {
        pub fn iter(&'a self) -> MapIter<'a, K, V> {
            MapIter::new(self)
        }
    }
    
    impl<K: Ord, V> std_Map<K, V> {
        pub fn new() -> Self {
            std_Map { x: BTreeMap::new() }
        }
        pub fn insert(&mut self, k: K, v: V) {
            self.x.insert(k, v);
        }
    }
    
    impl<K: FromRecord + Ord, V: FromRecord> FromRecord for std_Map<K, V> {
        fn from_record(val: &Record) -> Result<Self, String> {
            BTreeMap::from_record(val).map(|x| std_Map { x })
        }
    }
    
    impl<K: IntoRecord + Ord, V: IntoRecord> IntoRecord for std_Map<K, V> {
        fn into_record(self) -> Record {
            self.x.into_record()
        }
    }
    
    impl<K: FromRecord + Ord, V: FromRecord + PartialEq> Mutator<std_Map<K, V>> for Record {
        fn mutate(&self, map: &mut std_Map<K, V>) -> Result<(), String> {
            self.mutate(&mut map.x)
        }
    }
    
    impl<K: Ord, V> IntoIterator for std_Map<K, V> {
        type Item = (K, V);
        type IntoIter = btree_map::IntoIter<K, V>;
        fn into_iter(self) -> Self::IntoIter {
            self.x.into_iter()
        }
    }
    
    impl<K: Ord, V> FromIterator<(K, V)> for std_Map<K, V> {
        fn from_iter<I>(iter: I) -> Self
        where
            I: IntoIterator<Item = (K, V)>,
        {
            std_Map {
                x: BTreeMap::from_iter(iter),
            }
        }
    }
    
    impl<K: Display + Ord, V: Display> Display for std_Map<K, V> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            let len = self.x.len();
            formatter.write_str("[")?;
            for (i, (k, v)) in self.x.iter().enumerate() {
                formatter.write_fmt(format_args!("({},{})", *k, *v))?;
                if i < len - 1 {
                    formatter.write_str(",")?;
                }
            }
            formatter.write_str("]")?;
            Ok(())
        }
    }
    
    impl<K: fmt::Debug + Ord, V: fmt::Debug> fmt::Debug for std_Map<K, V> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            let len = self.x.len();
            formatter.write_str("[")?;
            for (i, (k, v)) in self.x.iter().enumerate() {
                formatter.write_fmt(format_args!("({:?},{:?})", *k, *v))?;
                if i < len - 1 {
                    formatter.write_str(",")?;
                }
            }
            formatter.write_str("]")?;
            Ok(())
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'a, K, V, F> FromFlatBuffer<fbrt::Vector<'a, F>> for std_Map<K, V>
    where
        F: fbrt::Follow<'a> + 'a,
        K: Ord,
        (K, V): FromFlatBuffer<F::Inner>,
    {
        fn from_flatbuf(fb: fbrt::Vector<'a, F>) -> Response<Self> {
            let mut m = std_Map::new();
            for x in FBIter::from_vector(fb) {
                let (k, v) = <(K, V)>::from_flatbuf(x)?;
                m.insert(k, v);
            }
            Ok(m)
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'b, K, V, T> ToFlatBuffer<'b> for std_Map<K, V>
    where
        K: Ord + Clone,
        V: Clone,
        (K, V): ToFlatBufferVectorElement<'b, Target = T>,
        T: 'b + fbrt::Push + Copy,
    {
        type Target = fbrt::WIPOffset<fbrt::Vector<'b, <T as fbrt::Push>::Output>>;
    
        fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
            let vec: Vec<<(K, V) as ToFlatBufferVectorElement<'b>>::Target> = self
                .iter()
                .map(|(k, v)| (k, v).to_flatbuf_vector_element(fbb))
                .collect();
            fbb.create_vector(vec.as_slice())
        }
    }
    
    pub fn std_map_empty<K: Ord + Clone, V: Clone>() -> std_Map<K, V> {
        std_Map::new()
    }
    
    pub fn std_map_singleton<K: Ord + Clone, V: Clone>(k: &K, v: &V) -> std_Map<K, V> {
        let mut m = std_Map::new();
        m.insert(k.clone(), v.clone());
        m
    }
    
    pub fn std_map_insert<K: Ord + Clone, V: Clone>(m: &mut std_Map<K, V>, k: &K, v: &V) {
        m.x.insert((*k).clone(), (*v).clone());
    }
    
    pub fn std_map_remove<K: Ord + Clone, V: Clone>(m: &mut std_Map<K, V>, k: &K) {
        m.x.remove(k);
    }
    
    pub fn std_map_insert_imm<K: Ord + Clone, V: Clone>(
        m: &std_Map<K, V>,
        k: &K,
        v: &V,
    ) -> std_Map<K, V> {
        let mut m2 = m.clone();
        m2.insert((*k).clone(), (*v).clone());
        m2
    }
    
    pub fn std_map_get<K: Ord, V: Clone>(m: &std_Map<K, V>, k: &K) -> std_Option<V> {
        option2std(m.x.get(k).cloned())
    }
    
    pub fn std_map_contains_key<K: Ord, V: Clone>(s: &std_Map<K, V>, k: &K) -> bool {
        s.x.contains_key(k)
    }
    
    pub fn std_map_is_empty<K: Ord, V: Clone>(m: &std_Map<K, V>) -> bool {
        m.x.is_empty()
    }
    
    pub fn std_map_union<K: Ord + Clone, V: Clone>(
        m1: &std_Map<K, V>,
        m2: &std_Map<K, V>,
    ) -> std_Map<K, V> {
        let mut m = m1.clone();
        m.x.append(&mut m2.x.clone());
        m
    }
    
    // strings
    
    pub fn std___builtin_2string<T: Display>(x: &T) -> String {
        format!("{}", *x).to_string()
    }
    
    pub fn std_hex<T: fmt::LowerHex>(x: &T) -> String {
        format!("{:x}", *x).to_string()
    }
    
    pub fn std_parse_dec_u64(s: &String) -> std_Option<u64> {
        option2std(s.parse::<u64>().ok())
    }
    
    pub fn std_parse_dec_i64(s: &String) -> std_Option<i64> {
        option2std(s.parse::<i64>().ok())
    }
    
    pub fn std_string_join(strings: &std_Vec<String>, sep: &String) -> String {
        strings.x.join(sep.as_str())
    }
    
    pub fn std_string_split(s: &String, sep: &String) -> std_Vec<String> {
        std_Vec {
            x: s.split(sep).map(|x| x.to_owned()).collect(),
        }
    }
    
    pub fn std_string_contains(s1: &String, s2: &String) -> bool {
        s1.contains(s2.as_str())
    }
    
    pub fn std_string_substr(s: &String, start: &u64, end: &u64) -> String {
        let len = s.len();
        let from = cmp::min(*start as usize, len);
        let to = cmp::max(from, cmp::min(*end as usize, len));
        s[from..to].to_string()
    }
    
    pub fn std_string_len(s: &String) -> u64 {
        s.len() as u64
    }
    
    pub fn std_str_to_lower(s: &String) -> String {
        s.to_lowercase()
    }
    
    // Hashing
    
    pub fn std_hash64<T: Hash>(x: &T) -> u64 {
        let mut hasher = XxHash::with_seed(XX_SEED1);
        x.hash(&mut hasher);
        hasher.finish()
    }
    
    pub fn std_hash128<T: Hash>(x: &T) -> u128 {
        let mut hasher = XxHash::with_seed(XX_SEED1);
        x.hash(&mut hasher);
        let w1 = hasher.finish();
        let mut hasher = XxHash::with_seed(XX_SEED2);
        x.hash(&mut hasher);
        let w2 = hasher.finish();
        ((w1 as u128) << 64) | (w2 as u128)
    }
    
    pub type ProjectFunc<X> = fn(&Value) -> X;
    
    /*
     * Group type (used in aggregation operators)
     */
    pub struct std_Group<'a, X> {
        /* TODO: remove "pub" */
        pub group: &'a [(&'a Value, Weight)],
        pub project: &'a ProjectFunc<X>,
    }
    
    /* This is needed so we can support for-loops over `Group`'s
     */
    pub struct GroupIter<'a, X> {
        iter: slice::Iter<'a, (&'a Value, Weight)>,
        project: &'a ProjectFunc<X>,
    }
    
    impl<'a, X> GroupIter<'a, X> {
        pub fn new(grp: &std_Group<'a, X>) -> GroupIter<'a, X> {
            GroupIter {
                iter: grp.group.iter(),
                project: grp.project,
            }
        }
    }
    
    impl<'a, X> Iterator for GroupIter<'a, X> {
        type Item = X;
    
        fn next(&mut self) -> Option<Self::Item> {
            match self.iter.next() {
                None => None,
                Some((x, _)) => Some((self.project)(x)),
            }
        }
    
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.iter.size_hint()
        }
    }
    
    impl<'a, X> std_Group<'a, X> {
        pub fn new(
            group: &'a [(&'a Value, Weight)],
            project: &'static ProjectFunc<X>,
        ) -> std_Group<'a, X> {
            std_Group {
                group: group,
                project: project,
            }
        }
    
        fn size(&self) -> u64 {
            self.group.len() as u64
        }
    
        fn first(&'a self) -> X {
            (self.project)(self.group[0].0)
        }
    
        fn nth_unchecked(&'a self, n: u64) -> X {
            (self.project)(self.group[n as usize].0)
        }
    
        pub fn iter(&'a self) -> GroupIter<'a, X> {
            GroupIter::new(self)
        }
    }
    
    impl<'a, X> std_Group<'a, X> {
        fn nth(&'a self, n: u64) -> std_Option<X> {
            if self.size() > n {
                std_Option::std_Some {
                    x: (self.project)(self.group[n as usize].0),
                }
            } else {
                std_Option::std_None
            }
        }
    }
    
    /*
     * Standard aggregation function
     */
    pub fn std_group_count<A>(g: &std_Group<A>) -> u64 {
        g.size()
    }
    
    pub fn std_group_first<A>(g: &std_Group<A>) -> A {
        g.first()
    }
    
    pub fn std_group_nth<A>(g: &std_Group<A>, n: &u64) -> std_Option<A> {
        g.nth(*n)
    }
    
    pub fn std_group2set<A: Ord + Clone>(g: &std_Group<A>) -> std_Set<A> {
        let mut res = std_Set::new();
        for v in g.iter() {
            std_set_insert(&mut res, &v);
        }
        res
    }
    
    pub fn std_group_set_unions<A: Ord + Clone>(g: &std_Group<std_Set<A>>) -> std_Set<A> {
        let mut res = std_Set::new();
        for gr in g.iter() {
            for v in gr.iter() {
                std_set_insert(&mut res, v);
            }
        }
        res
    }
    
    pub fn std_group_setref_unions<A: Ord + Clone>(
        g: &std_Group<std_Ref<std_Set<A>>>,
    ) -> std_Ref<std_Set<A>> {
        if g.size() == 1 {
            g.first()
        } else {
            let mut res: std_Ref<std_Set<A>> = std_ref_new(&std_Set::new());
            {
                let mut rres = std_Ref::get_mut(&mut res).unwrap();
                for gr in g.iter() {
                    for v in gr.iter() {
                        std_set_insert(&mut rres, &v);
                    }
                }
            }
            res
        }
    }
    
    pub fn std_group2vec<A: Ord + Clone>(g: &std_Group<A>) -> std_Vec<A> {
        let mut res = std_Vec::with_capacity(g.size() as usize);
        for v in g.iter() {
            std_vec_push(&mut res, &v);
        }
        res
    }
    
    pub fn std_group2map<K: Ord + Clone, V: Clone>(g: &std_Group<(K, V)>) -> std_Map<K, V> {
        let mut res = std_Map::new();
        for (k, v) in g.iter() {
            std_map_insert(&mut res, &k, &v);
        }
        res
    }
    
    pub fn std_group_min<A: Ord>(g: &std_Group<A>) -> A {
        g.iter().min().unwrap()
    }
    
    pub fn std_group_max<A: Ord>(g: &std_Group<A>) -> A {
        g.iter().max().unwrap()
    }
    
    pub fn std_group_sum<A: ops::Add + ops::AddAssign>(g: &std_Group<A>) -> A {
        let mut res = std_group_first(g);
        for v in g.iter().skip(1) {
            res += v;
        }
        res
    }
    
    /* Tuples */
    #[derive(Copy, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
    pub struct tuple0;
    
    impl FromRecord for tuple0 {
        fn from_record(val: &Record) -> Result<Self, String> {
            <()>::from_record(val).map(|_| tuple0)
        }
    }
    
    impl IntoRecord for tuple0 {
        fn into_record(self) -> Record {
            ().into_record()
        }
    }
    
    macro_rules! decl_tuple {
        ( $name:ident, $( $t:tt ),+ ) => {
            #[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
            pub struct $name< $($t),* >($(pub $t),*);
            impl <$($t: FromRecord),*> FromRecord for $name<$($t),*> {
                fn from_record(val: &Record) -> Result<Self, String> {
                    <($($t),*)>::from_record(val).map(|($($t),*)|$name($($t),*))
                }
            }
    
            impl <$($t: IntoRecord),*> IntoRecord for $name<$($t),*> {
                fn into_record(self) -> Record {
                    let $name($($t),*) = self;
                    Record::Tuple(vec![$($t.into_record()),*])
                }
            }
    
            impl <$($t: FromRecord),*> Mutator<$name<$($t),*>> for Record {
                fn mutate(&self, x: &mut $name<$($t),*>) -> Result<(), String> {
                    *x = <$name<$($t),*>>::from_record(self)?;
                    Ok(())
                }
            }
        };
    }
    
    decl_tuple!(tuple2, T1, T2);
    decl_tuple!(tuple3, T1, T2, T3);
    decl_tuple!(tuple4, T1, T2, T3, T4);
    decl_tuple!(tuple5, T1, T2, T3, T4, T5);
    decl_tuple!(tuple6, T1, T2, T3, T4, T5, T6);
    decl_tuple!(tuple7, T1, T2, T3, T4, T5, T6, T7);
    decl_tuple!(tuple8, T1, T2, T3, T4, T5, T6, T7, T8);
    decl_tuple!(tuple9, T1, T2, T3, T4, T5, T6, T7, T8, T9);
    decl_tuple!(tuple10, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10);
    decl_tuple!(tuple11, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11);
    decl_tuple!(tuple12, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12);
    decl_tuple!(tuple13, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13);
    decl_tuple!(tuple14, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14);
    decl_tuple!(tuple15, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15);
    decl_tuple!(tuple16, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16);
    decl_tuple!(tuple17, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17);
    decl_tuple!(
        tuple18, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18
    );
    decl_tuple!(
        tuple19, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19
    );
    decl_tuple!(
        tuple20, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,
        T20
    );
    
    // Endianness
    pub fn std_ntohl(x: &u32) -> u32 {
        u32::from_be(*x)
    }
    
    pub fn std_ntohs(x: &u16) -> u16 {
        u16::from_be(*x)
    }
    
    pub fn std_htonl(x: &u32) -> u32 {
        u32::to_be(*x)
    }
    
    pub fn std_htons(x: &u16) -> u16 {
        u16::to_be(*x)
    }
}
pub use __log::*;
mod __log {
    use super::*;
    use std::collections;
    use std::ffi;
    use std::sync;
    
    type log_callback_t = Box<dyn Fn(log_log_level_t, &str) + Send + Sync>;
    
    lazy_static! {
        /* Logger configuration for each module consists of the maximal enabled
         * log level (messages above this level are ignored) and callback.
         */
        static ref LOG_CONFIG: sync::RwLock<collections::HashMap<log_module_t, (log_callback_t, log_log_level_t)>> = {
            sync::RwLock::new(collections::HashMap::new())
        };
    }
    
    /*
     * Logging API exposed to the DDlog program.
     * (see detailed documentation in `log.dl`)
     */
    pub fn log_log(module: &log_module_t, level: &log_log_level_t, msg: &String) -> bool {
        if let Some((cb, current_level)) = LOG_CONFIG.read().unwrap().get(&module) {
            if *level <= *current_level {
                cb(*level, msg.as_str());
            }
        };
        true
    }
    
    /*
     * Configuration API
     * (detailed documentation in `ddlog_log.h`)
     *
     * `cb = None` - disables logging for the given module.
     *
     * NOTE: we set callback and log level simultaneously.  A more flexible API
     * would allow changing log level without changing the callback.
     */
    pub fn log_set_callback(
        module: log_module_t,
        cb: Option<log_callback_t>,
        max_level: log_log_level_t,
    ) {
        match cb {
            Some(cb) => {
                LOG_CONFIG.write().unwrap().insert(module, (cb, max_level));
            }
            None => {
                LOG_CONFIG.write().unwrap().remove(&module);
            }
        }
    }
    
    /*
     * C bindings for the config API
     */
    #[no_mangle]
    pub unsafe extern "C" fn ddlog_log_set_callback(
        module: raw::c_int,
        cb: Option<extern "C" fn(arg: libc::uintptr_t, level: raw::c_int, msg: *const raw::c_char)>,
        cb_arg: libc::uintptr_t,
        max_level: raw::c_int,
    ) {
        match cb {
            Some(cb) => log_set_callback(
                module as log_module_t,
                Some(Box::new(move |level, msg| {
                    cb(
                        cb_arg,
                        level as raw::c_int,
                        ffi::CString::new(msg).unwrap_or_default().as_ptr(),
                    )
                })),
                max_level as log_log_level_t,
            ),
            None => log_set_callback(module as log_module_t, None, max_level as log_log_level_t),
        }
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct Rel {
    arg1: String,
    arg2: String
}
impl Abomonation for Rel{}
impl <> record::FromRecord for Rel<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Rel" if _args.len() == 2 => {
                        Ok(Rel{arg1: <String>::from_record(&_args[0])?, arg2: <String>::from_record(&_args[1])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type Rel in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Rel" => {
                        Ok(Rel{arg1: record::arg_extract::<String>(_args, "arg1")?, arg2: record::arg_extract::<String>(_args, "arg2")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type Rel in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(Rel, <>, arg1, arg2);
decl_record_mutator_struct!(Rel, <>, arg1: String, arg2: String);
impl fmt::Display for Rel {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Rel{arg1,arg2} => {
                __formatter.write_str("Rel{")?;
                record::format_ddlog_str(arg1, __formatter)?;
                __formatter.write_str(",")?;
                record::format_ddlog_str(arg2, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for Rel {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Default)]
pub struct TransClosure {
    arg1: String,
    arg2: String
}
impl Abomonation for TransClosure{}
impl <> record::FromRecord for TransClosure<> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "TransClosure" if _args.len() == 2 => {
                        Ok(TransClosure{arg1: <String>::from_record(&_args[0])?, arg2: <String>::from_record(&_args[1])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TransClosure in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "TransClosure" => {
                        Ok(TransClosure{arg1: record::arg_extract::<String>(_args, "arg1")?, arg2: record::arg_extract::<String>(_args, "arg2")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type TransClosure in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(TransClosure, <>, arg1, arg2);
decl_record_mutator_struct!(TransClosure, <>, arg1: String, arg2: String);
impl fmt::Display for TransClosure {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            TransClosure{arg1,arg2} => {
                __formatter.write_str("TransClosure{")?;
                record::format_ddlog_str(arg1, __formatter)?;
                __formatter.write_str(",")?;
                record::format_ddlog_str(arg2, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for TransClosure {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
pub type log_log_level_t = i32;
pub type log_module_t = i32;
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize)]
pub enum std_Either<A, B> {
    std_Left {
        l: A
    },
    std_Right {
        r: B
    }
}
impl <A: Val, B: Val> Abomonation for std_Either<A, B>{}
impl <A: record::FromRecord + Default,B: record::FromRecord + Default> record::FromRecord for std_Either<A,B> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "std.Left" if _args.len() == 1 => {
                        Ok(std_Either::std_Left{l: <A>::from_record(&_args[0])?})
                    },
                    "std.Right" if _args.len() == 1 => {
                        Ok(std_Either::std_Right{r: <B>::from_record(&_args[0])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type std_Either in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "std.Left" => {
                        Ok(std_Either::std_Left{l: record::arg_extract::<A>(_args, "l")?})
                    },
                    "std.Right" => {
                        Ok(std_Either::std_Right{r: record::arg_extract::<B>(_args, "r")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type std_Either in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_enum_into_record!(std_Either, <A,B>, std_Left{l}, std_Right{r});
decl_record_mutator_enum!(std_Either, <A,B>, std_Left{l: A}, std_Right{r: B});
impl <A: fmt::Debug, B: fmt::Debug> fmt::Display for std_Either<A, B> {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            std_Either::std_Left{l} => {
                __formatter.write_str("std.Left{")?;
                fmt::Debug::fmt(l, __formatter)?;
                __formatter.write_str("}")
            },
            std_Either::std_Right{r} => {
                __formatter.write_str("std.Right{")?;
                fmt::Debug::fmt(r, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl <A: fmt::Debug, B: fmt::Debug> fmt::Debug for std_Either<A, B> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
impl  <A: Default, B: Default> Default for std_Either<A, B> {
    fn default() -> Self {
        std_Either::std_Left{l : Default::default()}
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize)]
pub enum std_Option<A> {
    std_None,
    std_Some {
        x: A
    }
}
impl <A: Val> Abomonation for std_Option<A>{}
impl <A: record::FromRecord + Default> record::FromRecord for std_Option<A> {
    fn from_record(val: &record::Record) -> Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "std.None" if _args.len() == 0 => {
                        Ok(std_Option::std_None{})
                    },
                    "std.Some" if _args.len() == 1 => {
                        Ok(std_Option::std_Some{x: <A>::from_record(&_args[0])?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type std_Option in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "std.None" => {
                        Ok(std_Option::std_None{})
                    },
                    "std.Some" => {
                        Ok(std_Option::std_Some{x: record::arg_extract::<A>(_args, "x")?})
                    },
                    c => Result::Err(format!("unknown constructor {} of type std_Option in {:?}", c, *val))
                }
            },
            v => {
                Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_enum_into_record!(std_Option, <A>, std_None{}, std_Some{x});
decl_record_mutator_enum!(std_Option, <A>, std_None{}, std_Some{x: A});
impl <A: fmt::Debug> fmt::Display for std_Option<A> {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            std_Option::std_None{} => {
                __formatter.write_str("std.None{")?;
                __formatter.write_str("}")
            },
            std_Option::std_Some{x} => {
                __formatter.write_str("std.Some{")?;
                fmt::Debug::fmt(x, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl <A: fmt::Debug> fmt::Debug for std_Option<A> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
impl  <A: Default> Default for std_Option<A> {
    fn default() -> Self {
        std_Option::std_None{}
    }
}
impl TryFrom<&str> for Relations {
    type Error = ();
    fn try_from(rname: &str) -> Result<Self, Self::Error> {
         match rname {
        "Rel" => Ok(Relations::Rel),
        "TransClosure" => Ok(Relations::TransClosure),
        "__Null" => Ok(Relations::__Null),
             _  => Err(())
         }
    }
}
impl Relations {
    pub fn is_output(&self) -> bool {
        match self {
        Relations::TransClosure => true,
            _  => false
        }
    }
}
impl Relations {
    pub fn is_input(&self) -> bool {
        match self {
        Relations::Rel => true,
            _  => false
        }
    }
}
impl TryFrom<RelId> for Relations {
    type Error = ();
    fn try_from(rid: RelId) -> Result<Self, Self::Error> {
         match rid {
        0 => Ok(Relations::Rel),
        1 => Ok(Relations::TransClosure),
        2 => Ok(Relations::__Null),
             _  => Err(())
         }
    }
}
pub fn relid2name(rid: RelId) -> Option<&'static str> {
   match rid {
        0 => Some(&"Rel"),
        1 => Some(&"TransClosure"),
        2 => Some(&"__Null"),
       _  => None
   }
}
pub fn relid2cname(rid: RelId) -> Option<&'static ffi::CStr> {
    RELIDMAPC.get(&rid).map(|c: &'static ffi::CString|c.as_ref())
}
lazy_static! {
    pub static ref RELIDMAP: FnvHashMap<Relations, &'static str> = {
        let mut m = FnvHashMap::default();
        m.insert(Relations::Rel, "Rel");
        m.insert(Relations::TransClosure, "TransClosure");
        m.insert(Relations::__Null, "__Null");
        m
   };
}
lazy_static! {
    pub static ref RELIDMAPC: FnvHashMap<RelId, ffi::CString> = {
        let mut m = FnvHashMap::default();
        m.insert(0, ffi::CString::new("Rel").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(1, ffi::CString::new("TransClosure").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(2, ffi::CString::new("__Null").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m
   };
}
lazy_static! {
    pub static ref INPUT_RELIDMAP: FnvHashMap<Relations, &'static str> = {
        let mut m = FnvHashMap::default();
        m.insert(Relations::Rel, "Rel");
        m
    };
}
lazy_static! {
    pub static ref OUTPUT_RELIDMAP: FnvHashMap<Relations, &'static str> = {
        let mut m = FnvHashMap::default();
        m.insert(Relations::TransClosure, "TransClosure");
        m
    };
}
impl TryFrom<&str> for Indexes {
    type Error = ();
    fn try_from(iname: &str) -> Result<Self, Self::Error> {
         match iname {
        "__Null_by_none" => Ok(Indexes::__Null_by_none),
             _  => Err(())
         }
    }
}
impl TryFrom<IdxId> for Indexes {
    type Error = ();
    fn try_from(iid: IdxId) -> Result<Self, Self::Error> {
         match iid {
        0 => Ok(Indexes::__Null_by_none),
             _  => Err(())
         }
    }
}
pub fn indexid2name(iid: IdxId) -> Option<&'static str> {
   match iid {
        0 => Some(&"__Null_by_none"),
       _  => None
   }
}
pub fn indexid2cname(iid: IdxId) -> Option<&'static ffi::CStr> {
    IDXIDMAPC.get(&iid).map(|c: &'static ffi::CString|c.as_ref())
}
lazy_static! {
    pub static ref IDXIDMAP: FnvHashMap<Indexes, &'static str> = {
        let mut m = FnvHashMap::default();
        m.insert(Indexes::__Null_by_none, "__Null_by_none");
        m
   };
}
lazy_static! {
    pub static ref IDXIDMAPC: FnvHashMap<IdxId, ffi::CString> = {
        let mut m = FnvHashMap::default();
        m.insert(0, ffi::CString::new("__Null_by_none").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert index name to C string").unwrap()));
        m
   };
}
pub fn relval_from_record(rel: Relations, _rec: &record::Record) -> Result<Value, String> {
    match rel {
        Relations::Rel => {
            Ok(Value::Rel(boxed::Box::new(<Rel>::from_record(_rec)?)))
        },
        Relations::TransClosure => {
            Ok(Value::TransClosure(boxed::Box::new(<TransClosure>::from_record(_rec)?)))
        },
        Relations::__Null => {
            Ok(Value::tuple0__(<()>::from_record(_rec)?))
        }
    }
}
pub fn relkey_from_record(rel: Relations, _rec: &record::Record) -> Result<Value, String> {
    match rel {
        _ => Err(format!("relation {:?} does not have a primary key", rel))
    }
}
pub fn idxkey_from_record(idx: Indexes, _rec: &record::Record) -> Result<Value, String> {
    match idx {
        Indexes::__Null_by_none => {
            Ok(Value::tuple0__(<()>::from_record(_rec)?))
        },
    }
}
pub fn indexes2arrid(idx: Indexes) -> ArrId {
    match idx {
        Indexes::__Null_by_none => ( 2, 0),
    }
}
#[derive(Copy,Clone,Debug,PartialEq,Eq,Hash)]
pub enum Relations {
    Rel = 0,
    TransClosure = 1,
    __Null = 2
}
#[derive(Copy,Clone,Debug,PartialEq,Eq,Hash)]
pub enum Indexes {
    __Null_by_none = 0
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
pub enum Value {
    string(boxed::Box<String>),
    tuple0__(()),
    Rel(boxed::Box<Rel>),
    TransClosure(boxed::Box<TransClosure>)
}
impl Abomonation for Value {}
impl Default for Value {
    fn default() -> Value {Value::tuple0__(())}
}
impl fmt::Display for Value {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Value::string (v) => record::format_ddlog_str(v.as_ref(), f),
            Value::tuple0__ (v) => write!(f, "{:?}", *v),
            Value::Rel (v) => write!(f, "{:?}", *v),
            Value::TransClosure (v) => write!(f, "{:?}", *v)
        }
    }
}
decl_val_enum_into_record!(Value, <>, string(x), tuple0__(x), Rel(x), TransClosure(x));
decl_record_mutator_val_enum!(Value, <>, string(String), tuple0__(()), Rel(Rel), TransClosure(TransClosure));
/* fn log_log(module: & log_module_t, level: & log_log_level_t, msg: & String) -> bool */
/* fn std___builtin_2string<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & X) -> String */
/* fn std_deref<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & std_Ref<A>) -> A */
/* fn std_group2map<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<(K, V)>) -> std_Map<K, V> */
/* fn std_group2set<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<A>) -> std_Set<A> */
/* fn std_group2vec<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<A>) -> std_Vec<A> */
/* fn std_group_count<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<A>) -> u64 */
/* fn std_group_first<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<A>) -> A */
/* fn std_group_max<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<A>) -> A */
/* fn std_group_min<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<A>) -> A */
/* fn std_group_nth<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<A>, n: & u64) -> std_Option<A> */
/* fn std_group_set_unions<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<std_Set<A>>) -> std_Set<A> */
/* fn std_group_setref_unions<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<std_Ref<std_Set<A>>>) -> std_Ref<std_Set<A>> */
/* fn std_group_sum<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<A>) -> A */
/* fn std_hash128<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & X) -> u128 */
/* fn std_hash64<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & X) -> u64 */
/* fn std_hex<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & X) -> String */
/* fn std_htonl(x: & u32) -> u32 */
/* fn std_htons(x: & u16) -> u16 */
/* fn std_map_contains_key<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(m: & std_Map<K, V>, k: & K) -> bool */
/* fn std_map_empty<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>() -> std_Map<K, V> */
/* fn std_map_get<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(m: & std_Map<K, V>, k: & K) -> std_Option<V> */
/* fn std_map_insert<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(m: &mut std_Map<K, V>, k: & K, v: & V) -> () */
/* fn std_map_insert_imm<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(m: & std_Map<K, V>, k: & K, v: & V) -> std_Map<K, V> */
/* fn std_map_is_empty<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(m: & std_Map<K, V>) -> bool */
/* fn std_map_remove<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(m: &mut std_Map<K, V>, k: & K) -> () */
/* fn std_map_singleton<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(k: & K, v: & V) -> std_Map<K, V> */
/* fn std_map_union<K: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,V: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(m1: & std_Map<K, V>, m2: & std_Map<K, V>) -> std_Map<K, V> */
/* fn std_ntohl(x: & u32) -> u32 */
/* fn std_ntohs(x: & u16) -> u16 */
/* fn std_parse_dec_i64(s: & String) -> std_Option<i64> */
/* fn std_parse_dec_u64(s: & String) -> std_Option<u64> */
/* fn std_pow32<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(base: & A, exp: & u32) -> A */
/* fn std_range<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(from: & A, to: & A, step: & A) -> std_Vec<A> */
/* fn std_ref_new<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & A) -> std_Ref<A> */
/* fn std_set2vec<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s: & std_Set<A>) -> std_Vec<A> */
/* fn std_set_contains<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s: & std_Set<X>, v: & X) -> bool */
/* fn std_set_empty<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>() -> std_Set<X> */
/* fn std_set_insert<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s: &mut std_Set<X>, v: & X) -> () */
/* fn std_set_insert_imm<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s: & std_Set<X>, v: & X) -> std_Set<X> */
/* fn std_set_is_empty<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s: & std_Set<X>) -> bool */
/* fn std_set_nth<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s: & std_Set<X>, n: & u64) -> std_Option<X> */
/* fn std_set_singleton<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & X) -> std_Set<X> */
/* fn std_set_size<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s: & std_Set<X>) -> u64 */
/* fn std_set_union<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s1: & std_Set<X>, s2: & std_Set<X>) -> std_Set<X> */
/* fn std_set_unions<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(sets: & std_Vec<std_Set<X>>) -> std_Set<X> */
/* fn std_str_to_lower(s: & String) -> String */
/* fn std_string_contains(s1: & String, s2: & String) -> bool */
/* fn std_string_join(strings: & std_Vec<String>, sep: & String) -> String */
/* fn std_string_len(s: & String) -> u64 */
/* fn std_string_split(s: & String, sep: & String) -> std_Vec<String> */
/* fn std_string_substr(s: & String, start: & u64, end: & u64) -> String */
/* fn std_vec2set<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(s: & std_Vec<A>) -> std_Set<A> */
/* fn std_vec_contains<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(v: & std_Vec<X>, x: & X) -> bool */
/* fn std_vec_empty<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>() -> std_Vec<A> */
/* fn std_vec_is_empty<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(v: & std_Vec<X>) -> bool */
/* fn std_vec_len<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(v: & std_Vec<X>) -> u64 */
/* fn std_vec_nth<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(v: & std_Vec<X>, n: & u64) -> std_Option<X> */
/* fn std_vec_push<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(v: &mut std_Vec<X>, x: & X) -> () */
/* fn std_vec_push_imm<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(v: & std_Vec<X>, x: & X) -> std_Vec<X> */
/* fn std_vec_singleton<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & X) -> std_Vec<X> */
fn std_group_unzip<X: Eq + Ord + Clone + Hash + PartialEq + PartialOrd,Y: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(g: & std_Group<(X, Y)>) -> (std_Vec<X>, std_Vec<Y>)
{   let ref mut xs : std_Vec<X> = std_vec_empty();
    let ref mut ys : std_Vec<Y> = std_vec_empty();
    for ref v in g.iter() {
        {
            let (ref mut x, ref mut y) = v.clone();
            std_vec_push(xs, x);
            std_vec_push(ys, y)
        }
    };
    (xs.clone(), ys.clone())
}
fn std_is_none<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & std_Option<A>) -> bool
{   match (*x) {
        std_Option::std_None{} => true,
        _ => false
    }
}
fn std_is_some<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & std_Option<A>) -> bool
{   match (*x) {
        std_Option::std_Some{x: _} => true,
        _ => false
    }
}
fn std_max<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & A, y: & A) -> A
{   if (x.clone() > y.clone()) {
        x.clone()
    } else {
        y.clone()
    }
}
fn std_min<A: Eq + Ord + Clone + Hash + PartialEq + PartialOrd>(x: & A, y: & A) -> A
{   if (x.clone() < y.clone()) {
        x.clone()
    } else {
        y.clone()
    }
}
pub fn prog(__update_cb: Box<dyn CBFn<Value>>) -> Program<Value> {
    let Rel = Relation {
                  name:         "Rel".to_string(),
                  input:        true,
                  distinct:     false,
                  key_func:     None,
                  id:           Relations::Rel as RelId,
                  rules:        vec![
                      ],
                  arrangements: vec![
                      ],
                  change_cb:    None
              };
    let TransClosure = Relation {
                           name:         "TransClosure".to_string(),
                           input:        false,
                           distinct:     false,
                           key_func:     None,
                           id:           Relations::TransClosure as RelId,
                           rules:        vec![
                               /* TransClosure(.arg1=x, .arg2=y) :- Rel(.arg1=x, .arg2=y). */
                               Rule::CollectionRule {
                                   description: "TransClosure(.arg1=x, .arg2=y) :- Rel(.arg1=x, .arg2=y).".to_string(),
                                   rel: Relations::Rel as RelId,
                                   xform: Some(XFormCollection::FilterMap{
                                                   description: "head of TransClosure(.arg1=x, .arg2=y) :- Rel(.arg1=x, .arg2=y)." .to_string(),
                                                   fmfun: &{fn __f(__v: Value) -> Option<Value>
                                                   {
                                                       let (x, y) = match __v{
                                                           Value::Rel(ref __box) => {
                                                               match **__box {
                                                               Rel{arg1: ref x, arg2: ref y} => (x, y),
                                                               _ => return None
                                                               }
                                                           },
                                                           _ => return None
                                                       };
                                                       Some(Value::TransClosure(boxed::Box::new(TransClosure{arg1: x.clone(), arg2: y.clone()})))
                                                   }
                                                   __f},
                                                   next: Box::new(None)
                                               })
                               },
                               /* TransClosure(.arg1=x, .arg2=z) :- TransClosure(.arg1=x, .arg2=y), TransClosure(.arg1=y, .arg2=z). */
                               Rule::ArrangementRule {
                                   description: "TransClosure(.arg1=x, .arg2=z) :- TransClosure(.arg1=x, .arg2=y), TransClosure(.arg1=y, .arg2=z).".to_string(),
                                   arr: ( Relations::TransClosure as RelId, 0),
                                   xform: XFormArrangement::Join{
                                              description: "TransClosure(.arg1=x, .arg2=y), TransClosure(.arg1=y, .arg2=z)".to_string(),
                                              ffun: None,
                                              arrangement: (Relations::TransClosure as RelId,1),
                                              jfun: &{fn __f(_: &Value ,__v1: &Value,__v2: &Value) -> Option<Value>
                                              {
                                                  let (x, y) = match *__v1{
                                                      Value::TransClosure(ref __box) => {
                                                          match **__box {
                                                          TransClosure{arg1: ref x, arg2: ref y} => (x, y),
                                                          _ => return None
                                                          }
                                                      },
                                                      _ => return None
                                                  };
                                                  let z = match *__v2{
                                                      Value::TransClosure(ref __box) => {
                                                          match **__box {
                                                          TransClosure{arg1: _, arg2: ref z} => z,
                                                          _ => return None
                                                          }
                                                      },
                                                      _ => return None
                                                  };
                                                  Some(Value::TransClosure(boxed::Box::new(TransClosure{arg1: x.clone(), arg2: z.clone()})))
                                              }
                                              __f},
                                              next: Box::new(None)
                                          }
                               }],
                           arrangements: vec![
                               Arrangement::Map{
                                  name: r###"TransClosure{.arg1=_, .arg2=_0}"###.to_string(),
                                   afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                   {
                                       let __cloned = __v.clone();
                                       {
                                           if let Value::TransClosure(__box) = __v {
                                               match *__box {
                                               TransClosure{arg1: _, arg2: ref _0} => Some(Value::string(boxed::Box::new(_0.clone()))),
                                               _ => None
                                               }
                                           } else { None }
                                       }.map(|x|(x,__cloned))
                                   }
                                   __f},
                                   queryable: false
                               },
                               Arrangement::Map{
                                  name: r###"TransClosure{.arg1=_0, .arg2=_}"###.to_string(),
                                   afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                                   {
                                       let __cloned = __v.clone();
                                       {
                                           if let Value::TransClosure(__box) = __v {
                                               match *__box {
                                               TransClosure{arg1: ref _0, arg2: _} => Some(Value::string(boxed::Box::new(_0.clone()))),
                                               _ => None
                                               }
                                           } else { None }
                                       }.map(|x|(x,__cloned))
                                   }
                                   __f},
                                   queryable: false
                               }],
                           change_cb:    Some(sync::Arc::new(sync::Mutex::new(__update_cb.clone())))
                       };
    let __Null = Relation {
                     name:         "__Null".to_string(),
                     input:        false,
                     distinct:     false,
                     key_func:     None,
                     id:           Relations::__Null as RelId,
                     rules:        vec![
                         ],
                     arrangements: vec![
                         Arrangement::Map{
                            name: r###"_"###.to_string(),
                             afun: &{fn __f(__v: Value) -> Option<(Value,Value)>
                             {
                                 let __cloned = __v.clone();
                                 {
                                     if let Value::tuple0__(__box) = __v {
                                         match __box {
                                         _ => Some(Value::tuple0__(())),
                                         _ => None
                                         }
                                     } else { None }
                                 }.map(|x|(x,__cloned))
                             }
                             __f},
                             queryable: true
                         }],
                     change_cb:    None
                 };
    Program {
        nodes: vec![
            ProgNode::Rel{rel: Rel},
            ProgNode::SCC{rels: vec![RecursiveRelation{rel: TransClosure, distinct: true}]},
            ProgNode::Rel{rel: __Null}
        ],
        init_data: vec![
        ]
    }
}